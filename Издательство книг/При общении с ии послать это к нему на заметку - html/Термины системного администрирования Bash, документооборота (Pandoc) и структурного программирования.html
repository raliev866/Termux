<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Термины системного администрирования Bash, документооборота (Pandoc) и структурного программирования</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/storage/emulated/0/Documents/15_Настройки_скрипты_Termux_бекап_рестор/Шаблон_формата_текста/HTML_книги/scientific_style.css" />
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#системное-администрирование-bashunixlinux"
id="toc-системное-администрирование-bashunixlinux"><strong>1. Системное
администрирование (Bash/Unix/Linux)</strong></a></li>
<li><a href="#документооборот-и-конвертация-pandoc"
id="toc-документооборот-и-конвертация-pandoc"><strong>2. Документооборот
и конвертация (Pandoc)</strong></a></li>
<li><a href="#структурное-программирование"
id="toc-структурное-программирование"><strong>3. Структурное
программирование</strong></a></li>
<li><a
href="#системное-администрирование-и-среда-выполнения-bashunixlinux"
id="toc-системное-администрирование-и-среда-выполнения-bashunixlinux"><strong>1.
Системное администрирование и среда выполнения
(Bash/Unix/Linux)</strong></a></li>
<li><a href="#документооборот-и-конвертация-pandoc-1"
id="toc-документооборот-и-конвертация-pandoc-1"><strong>2.
Документооборот и конвертация (Pandoc)</strong></a></li>
<li><a href="#структурное-программирование-и-архитектура"
id="toc-структурное-программирование-и-архитектура"><strong>3.
Структурное программирование и архитектура</strong></a></li>
<li><a href="#продолжение-расширенного-глоссария-часть-3"
id="toc-продолжение-расширенного-глоссария-часть-3"><strong>ПРОДОЛЖЕНИЕ
РАСШИРЕННОГО ГЛОССАРИЯ (Часть 3)</strong></a>
<ul>
<li><a
href="#системное-администрирование-и-среда-выполнения-bashunixlinux-1"
id="toc-системное-администрирование-и-среда-выполнения-bashunixlinux-1"><strong>1.
Системное администрирование и среда выполнения
(Bash/Unix/Linux)</strong></a></li>
<li><a href="#документооборот-и-конвертация-pandoc-2"
id="toc-документооборот-и-конвертация-pandoc-2"><strong>2.
Документооборот и конвертация (Pandoc)</strong></a></li>
<li><a href="#структурное-программирование-и-архитектура-1"
id="toc-структурное-программирование-и-архитектура-1"><strong>3.
Структурное программирование и архитектура</strong></a></li>
<li><a href="#дополнительные-полезные-термины"
id="toc-дополнительные-полезные-термины"><strong>4. Дополнительные
полезные термины</strong></a></li>
</ul></li>
</ul>
</nav>
<p>Здравствуйте! Это отличный запрос. Понимать терминологию — значит
говорить на одном языке и получать именно те решения, которые нужны. Я
изучил вопрос и подготовил для вас расширенный глоссарий,
структурированный по трём направлениям, которые вы указали.</p>
<p>Этот список не повторяет предыдущие термины, а дополняет их новыми
понятиями, которые обязательно встретятся в нашей работе.</p>
<hr />
<h3 id="системное-администрирование-bashunixlinux"><strong>1. Системное
администрирование (Bash/Unix/Linux)</strong></h3>
<p>Эта область отвечает за то, <em>как</em> скрипт взаимодействует с
системой, управляет файлами и процессами.</p>
<ul>
<li><strong>Daemon</strong>:
<ul>
<li><strong>Определение</strong>: Фоновая программа, которая запускается
при старте системы и выполняет различные задачи без прямого
взаимодействия с пользователем . Например, <code>sshd</code> (демон SSH)
ожидает подключений, а <code>cron</code> (демон планировщика) запускает
задачи по расписанию.</li>
<li><strong>Аналогия</strong>: Как портье в отеле, который всегда на
месте, но вы его замечаете, только когда вам что-то нужно.</li>
</ul></li>
<li><strong>Signal (Сигнал)</strong>:
<ul>
<li><strong>Определение</strong>: Асинхронное уведомление, отправляемое
процессу для уведомления о событии или для управления им (например,
запрос на завершение). Команда <code>kill</code> на самом деле
отправляет сигналы. Самые известные: <code>SIGTERM</code> (вежливо
попросить завершиться) и <code>SIGKILL</code> (принудительно
остановить).</li>
<li><strong>Аналогия</strong>: Как свисток судьи на футбольном поле —
игроки (процессы) должны на него отреагировать.</li>
</ul></li>
<li><strong>Shebang (также <code>#!</code>)</strong>:
<ul>
<li><strong>Определение</strong>: Последовательность символов
<code>#!</code> в самом начале скрипта, за которой следует путь к
интерпретатору (например, <code>#!/bin/bash</code> или
<code>#!/usr/bin/env python3</code>). Это указание операционной системе,
какую программу использовать для выполнения этого файла.</li>
<li><strong>Для нашей работы</strong>: Критически важная вещь, которую
мы уже используем. Без нее система не поймет, что наш файл — это скрипт,
который нужно выполнить.</li>
</ul></li>
<li><strong>POSIX (Portable Operating System Interface)</strong>:
<ul>
<li><strong>Определение</strong>: Семейство стандартов, разработанных
для обеспечения совместимости между различными операционными системами.
Для нас это означает “переносимый” код. Написание Bash-скриптов в стиле
POSIX гарантирует, что они с большей вероятностью будут работать в
разных Unix-подобных средах, а не только в конкретной версии Bash.</li>
<li><strong>Для нашей работы</strong>: Полезно знать при создании
действительно универсальных скриптов.</li>
</ul></li>
<li><strong>Globbing (Подстановка)</strong>:
<ul>
<li><strong>Определение</strong>: Механизм, используемый shell’ом для
сопоставления шаблонов с именами файлов. Например, <code>*.txt</code> —
это шаблон globbing, который расширяется до списка всех файлов,
оканчивающихся на <code>.txt</code> в текущей директории. Важно не
путать с регулярными выражениями, которые работают иначе.</li>
</ul></li>
<li><strong>File Descriptor (Файловый дескриптор)</strong>:
<ul>
<li><strong>Определение</strong>: Уникальный номер (целое число),
который операционная система присваивает открытому файлу, сокету или
другому потоку ввода-вывода для его идентификации. Стандартные потоки: 0
(<code>stdin</code>), 1 (<code>stdout</code>), 2
(<code>stderr</code>).</li>
</ul></li>
</ul>
<h3 id="документооборот-и-конвертация-pandoc"><strong>2. Документооборот
и конвертация (Pandoc)</strong></h3>
<p>Здесь собраны термины, касающиеся структуры документа, его элементов
и процесса конвертации.</p>
<ul>
<li><strong>Abstract Syntax Tree (AST)</strong>:
<ul>
<li><strong>Определение</strong>: Внутреннее древовидное представление
структуры документа, которое Pandoc создает после чтения исходного
формата и перед записью в целевой. Любой документ (Markdown, DOCX, HTML)
сначала преобразуется в AST . Это позволяет Pandoc быть
“форматно-независимым” на этапе обработки.</li>
<li><strong>Для нашей работы</strong>: Понимание AST объясняет, почему
Pandoc может терять или неправильно интерпретировать сложные элементы —
если они не описаны в его внутренней модели данных.</li>
</ul></li>
<li><strong>Metadata Block (Блок метаданных)</strong>:
<ul>
<li><strong>Определение</strong>: Структурированная информация о самом
документе, которая обычно размещается в начале файла. В Markdown это
формат YAML, заключенный между <code>---</code>. Содержит такие поля,
как <code>title:</code>, <code>author:</code>, <code>date:</code>,
<code>abstract:</code>. Мы уже активно это используем.</li>
</ul></li>
<li><strong>Filter (Фильтр)</strong>:
<ul>
<li><strong>Определение</strong>: Внешняя программа, которая может
модифицировать AST документа в процессе конвертации между чтением и
записью. Это мощный инструмент для создания собственных преобразований,
которые невозможно сделать стандартными средствами Pandoc.</li>
<li><strong>Для нашей работы</strong>: Например, можно написать фильтр
на Python, который будет находить в тексте все сноски и автоматически
форматировать их особым образом.</li>
</ul></li>
<li><strong>Template (Шаблон)</strong>:
<ul>
<li><strong>Определение</strong>: Файл, определяющий структуру выходного
документа. Pandoc использует встроенные шаблоны, но позволяет
переопределить их своими. Именно в шаблонах прописывается, куда вставить
метаданные (заголовок, автора), как оформить колонтитулы и т.д.
<code>--reference-doc</code> — это частный случай шаблона для формата
docx.</li>
</ul></li>
<li><strong>Div / Span</strong>:
<ul>
<li><strong>Определение</strong>: Элементы-контейнеры в Pandoc (и HTML).
<code>Div</code> используется для блоков (например, целый абзац или
несколько абзацев), а <code>Span</code> — для фрагментов текста внутри
строки. Они позволяют применять атрибуты (классы, идентификаторы) к
целым разделам документа.</li>
</ul></li>
</ul>
<h3 id="структурное-программирование"><strong>3. Структурное
программирование</strong></h3>
<p>Это общие принципы и парадигмы написания кода, которые делают его
надежным, понятным и легко поддерживаемым .</p>
<ul>
<li><strong>DRY (Don’t Repeat Yourself)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, призывающий избегать
дублирования кода. Любая часть знания или логики должна иметь
единственное, непротиворечивое представление в системе. Вместо
копирования одного и того же блока кода в десять мест, мы выносим его в
функцию.</li>
<li><strong>Для нашей работы</strong>: Мы реализовали это, создав скрипт
<code>генератор</code>, который создает все остальные команды по
шаблону.</li>
</ul></li>
<li><strong>KISS (Keep It Simple, Stupid!)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип проектирования, утверждающий,
что простота системы — ключ к ее успешной работе. Сложные, навороченные
решения всегда хуже простых и понятных, так как их сложнее отлаживать,
поддерживать и документировать.</li>
</ul></li>
<li><strong>Separation of Concerns (Разделение
ответственности)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, при котором программа
разбивается на отдельные части, решающие свои узкие задачи, с
минимальным пересечением функциональности. Например, один скрипт
отвечает за поиск файлов, другой — за их конвертацию, третий — за
логирование.</li>
</ul></li>
<li><strong>Idempotence (Идемпотентность)</strong>:
<ul>
<li><strong>Определение</strong>: Мы его уже подробно разбирали.
Повторюсь, так как это стержневое понятие: свойство операции, при
котором многократное её применение даёт тот же результат, что и
однократное. Это то, что делает наши скрипты безопасными для повторного
запуска.</li>
</ul></li>
<li><strong>Refactoring (Рефакторинг)</strong>:
<ul>
<li><strong>Определение</strong>: Процесс изменения внутренней структуры
программы без изменения её внешнего поведения. Мы занимались
рефакторингом, когда переписывали логику создания папок, чтобы сделать
её более понятной, но при этом она продолжала выполнять ту же задачу
(конвертировать файлы).</li>
</ul></li>
</ul>
<p>Этот список — не просто набор определений, а “алфавит”, с помощью
которого мы можем строить сложные и надежные системы. Если вы готовы
двигаться дальше, я могу продолжить и добавить термины из смежных
областей, например, по работе с системами контроля версий (Git) или по
более глубокой автоматизации в Termux.</p>
<p>Здравствуйте! Рад продолжить. Проанализировав дополнительные
источники, я подготовил вторую часть расширенного глоссария. Здесь
собраны термины, которые органично дополняют три указанные вами области
и будут полезны в нашей дальнейшей работе.</p>
<hr />
<h3
id="системное-администрирование-и-среда-выполнения-bashunixlinux"><strong>1.
Системное администрирование и среда выполнения
(Bash/Unix/Linux)</strong></h3>
<p>Эти термины описывают среду, в которой работают наши скрипты, и то,
как они с ней взаимодействуют.</p>
<ul>
<li><strong>Environment Variable (Переменная окружения)</strong>:
<ul>
<li><strong>Определение</strong>: Динамическая именованная пара
“ключ-значение”, хранящаяся в памяти и доступная всем процессам,
запущенным в данной среде . Она используется для передачи
конфигурационной информации (пути, настройки) программам. Например,
переменная <code>PATH</code> содержит список директорий для поиска
исполняемых файлов .</li>
<li><strong>Для нашей работы</strong>: Мы уже используем
<code>PATH</code>, чтобы наши команды (<code>генератор</code>,
<code>мддок</code>) были доступны из любой точки.</li>
</ul></li>
<li><strong>File Permissions (Права доступа к файлам)</strong>:
<ul>
<li><strong>Определение</strong>: Атрибуты файловой системы,
определяющие, какие пользователи и группы могут читать (<code>r</code>),
записывать (<code>w</code>) или исполнять (<code>x</code>) файл . Это
основа безопасности в Linux.</li>
<li><strong>Для нашей работы</strong>: Именно здесь возникает ошибка
<code>Permission denied</code>. Команда <code>chmod +x</code> изменяет
эти права, добавляя флаг “исполняемый”.</li>
</ul></li>
<li><strong>Shebang (также <code>#!</code>)</strong>:
<ul>
<li><strong>Определение</strong>: Последовательность символов
<code>#!</code> в самом начале скрипта, за которой следует путь к
интерпретатору (например, <code>#!/bin/bash</code> или
<code>#!/usr/bin/env python3</code>) . Это указание операционной
системе, какую программу использовать для выполнения этого файла. Без
нее система не поймет, что наш файл — это скрипт.</li>
</ul></li>
<li><strong>Alias (Алиас, псевдоним)</strong>:
<ul>
<li><strong>Определение</strong>: Механизм в командной оболочке (shell),
позволяющий создать короткую команду-псевдоним для более длинной строки
. Например, <code>alias ll='ls -la'</code>. Алиасы существуют только в
памяти текущей сессии shell.</li>
<li><strong>Для нашей работы</strong>: Мы используем алиасы в
<code>.bashrc</code> как один из способов регистрации команд.</li>
</ul></li>
<li><strong>Symbolic Link (Символическая ссылка, симлинк)</strong>:
<ul>
<li><strong>Определение</strong>: Специальный тип файла, который
является указателем на другой файл или директорию . Если представить,
что оригинальный файл — это человек, то симлинк — это его постоянный
адрес проживания. Даже если человек уйдет, адрес останется.</li>
<li><strong>Для нашей работы</strong>: Мы создаем симлинки в папке
<code>~/bin</code>, которые указывают на реальные скрипты в
<code>~/.termux_scripts</code>. Это позволяет вызывать их как обычные
команды, не добавляя сам скрипт в <code>PATH</code>.</li>
</ul></li>
<li><strong>Standard Streams (Стандартные потоки)</strong>:
<ul>
<li><strong>Определение</strong>: Три предопределенных канала
ввода-вывода, которые есть у каждого процесса: <strong>stdin</strong>
(0, стандартный ввод — обычно клавиатура), <strong>stdout</strong> (1,
стандартный вывод — экран) и <strong>stderr</strong> (2, стандартный
вывод ошибок — тоже экран) .</li>
<li><strong>Для нашей работы</strong>: Перенаправление потоков
(<code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>,
<code>|</code>) — это база для создания сложных конвейеров обработки
данных. Например, <code>find ... 2&gt;/dev/null</code> перенаправляет
ошибки поиска в “никуда”.</li>
</ul></li>
</ul>
<h3 id="документооборот-и-конвертация-pandoc-1"><strong>2.
Документооборот и конвертация (Pandoc)</strong></h3>
<p>Здесь собраны термины, касающиеся структуры документа, его элементов
и процесса конвертации.</p>
<ul>
<li><strong>Abstract Syntax Tree (AST)</strong>:
<ul>
<li><strong>Определение</strong>: Внутреннее древовидное представление
структуры документа, которое Pandoc создает после чтения исходного
формата и перед записью в целевой. Любой документ (Markdown, DOCX, HTML)
сначала преобразуется в AST. Это позволяет Pandoc быть
“форматно-независимым” на этапе обработки.</li>
<li><strong>Для нашей работы</strong>: Понимание AST объясняет, почему
Pandoc может терять или неправильно интерпретивать сложные элементы —
если они не описаны в его внутренней модели данных.</li>
</ul></li>
<li><strong>Metadata Block (Блок метаданных)</strong>:
<ul>
<li><strong>Определение</strong>: Структурированная информация о самом
документе, которая обычно размещается в начале файла. В Markdown это
формат YAML, заключенный между <code>---</code>. Содержит такие поля,
как <code>title:</code>, <code>author:</code>, <code>date:</code>,
<code>abstract:</code>. Мы уже активно это используем.</li>
</ul></li>
<li><strong>Filter (Фильтр)</strong>:
<ul>
<li><strong>Определение</strong>: Внешняя программа, которая может
модифицировать AST документа в процессе конвертации между чтением и
записью. Это мощный инструмент для создания собственных преобразований,
которые невозможно сделать стандартными средствами Pandoc.</li>
<li><strong>Для нашей работы</strong>: Например, можно написать фильтр
на Python, который будет находить в тексте все сноски и автоматически
форматировать их особым образом.</li>
</ul></li>
<li><strong>Template (Шаблон)</strong>:
<ul>
<li><strong>Определение</strong>: Файл, определяющий структуру выходного
документа. Pandoc использует встроенные шаблоны, но позволяет
переопределить их своими. Именно в шаблонах прописывается, куда вставить
метаданные (заголовок, автора), как оформить колонтитулы и т.д.
<code>--reference-doc</code> — это частный случай шаблона для формата
docx .</li>
</ul></li>
<li><strong>Div / Span</strong>:
<ul>
<li><strong>Определение</strong>: Элементы-контейнеры в Pandoc (и HTML).
<code>Div</code> используется для блоков (например, целый абзац или
несколько абзацев), а <code>Span</code> — для фрагментов текста внутри
строки. Они позволяют применять атрибуты (классы, идентификаторы) к
целым разделам документа.</li>
</ul></li>
<li><strong>Blocks / Fields (Блоки и поля)</strong>:
<ul>
<li><strong>Определение</strong>: В терминологии редакторов документов
(как PandaDoc), блоки — это перетаскиваемые элементы для построения
контента (текст, таблица, изображение) . Поля — это элементы для сбора
информации от получателя (подпись, дата) . В контексте Pandoc это
соответствует структуре документа.</li>
</ul></li>
</ul>
<h3 id="структурное-программирование-и-архитектура"><strong>3.
Структурное программирование и архитектура</strong></h3>
<p>Это общие принципы и парадигмы написания кода, которые делают его
надежным, понятным и легко поддерживаемым .</p>
<ul>
<li><strong>Structured Programming (Структурное
программирование)</strong>:
<ul>
<li><strong>Определение</strong>: Парадигма программирования, возникшая
как ответ на “кризис ПО” 1960-х годов . В её основе лежит представление
любой программы в виде иерархической структуры, построенной всего из
трёх базовых управляющих конструкций:
<strong>последовательность</strong> (выполнение команд по порядку),
<strong>ветвление</strong> (выбор одного из путей,
<code>if-then-else</code>) и <strong>цикл</strong> (повторение,
<code>while</code>, <code>for</code>) . Ключевой идеей был отказ от
использования оператора безусловного перехода (<code>goto</code>),
который делал код запутанным (“спагетти-код”) .</li>
<li><strong>Для нашей работы</strong>: Это философская база, на которой
строятся наши скрипты. Мы пишем код, используя именно эти три
конструкции, что делает его читаемым и предсказуемым.</li>
</ul></li>
<li><strong>DRY (Don’t Repeat Yourself)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, призывающий избегать
дублирования кода. Любая часть знания или логики должна иметь
единственное, непротиворечивое представление в системе. Вместо
копирования одного и того же блока кода в десять мест, мы выносим его в
функцию.</li>
<li><strong>Для нашей работы</strong>: Мы реализовали это, создав скрипт
<code>генератор</code>, который создает все остальные команды по
шаблону.</li>
</ul></li>
<li><strong>KISS (Keep It Simple, Stupid!)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип проектирования, утверждающий,
что простота системы — ключ к ее успешной работе. Сложные, навороченные
решения всегда хуже простых и понятных, так как их сложнее отлаживать,
поддерживать и документировать.</li>
</ul></li>
<li><strong>Separation of Concerns (Разделение
ответственности)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, при котором программа
разбивается на отдельные части, решающие свои узкие задачи, с
минимальным пересечением функциональности. Например, один скрипт
отвечает за поиск файлов, другой — за их конвертацию, третий — за
логирование.</li>
</ul></li>
<li><strong>Refactoring (Рефакторинг)</strong>:
<ul>
<li><strong>Определение</strong>: Процесс изменения внутренней структуры
программы без изменения её внешнего поведения. Мы занимались
рефакторингом, когда переписывали логику создания папок, чтобы сделать
её более понятной, но при этом она продолжала выполнять ту же задачу
(конвертировать файлы).</li>
</ul></li>
</ul>
<p>Этот список — не просто набор определений, а “алфавит”, с помощью
которого мы можем строить сложные и надежные системы. Понимание этих
терминов позволяет нам говорить на одном языке и точнее формулировать
задачи.</p>
<p>Если вы готовы двигаться дальше, я могу продолжить и добавить термины
из смежных областей, например, по работе с системами контроля версий
(Git) или по более глубокой автоматизации в Termux.</p>
<p>Здравствуйте! Продолжаю расширять наш терминологический словарь.
Проанализировав дополнительные источники, я подготовил третью часть
глоссария с новыми понятиями, которые органично дополняют три указанные
области.</p>
<hr />
<h2 id="продолжение-расширенного-глоссария-часть-3"><strong>ПРОДОЛЖЕНИЕ
РАСШИРЕННОГО ГЛОССАРИЯ (Часть 3)</strong></h2>
<h3
id="системное-администрирование-и-среда-выполнения-bashunixlinux-1"><strong>1.
Системное администрирование и среда выполнения
(Bash/Unix/Linux)</strong></h3>
<ul>
<li><strong>Daemon (Демон)</strong>:
<ul>
<li><strong>Определение</strong>: Фоновая программа, которая запускается
при старте системы и выполняет различные задачи без прямого
взаимодействия с пользователем . Она “живет” в памяти и ожидает
определенных событий или выполняет действия по расписанию. Например,
<code>sshd</code> (демон SSH) ожидает подключений, а <code>cron</code>
(демон-планировщик) запускает задачи по расписанию.</li>
<li><strong>Аналогия</strong>: Как портье в отеле, который всегда на
месте, но вы его замечаете, только когда вам что-то нужно.</li>
</ul></li>
<li><strong>Signal (Сигнал)</strong>:
<ul>
<li><strong>Определение</strong>: Асинхронное уведомление, отправляемое
процессу для уведомления о событии или для управления им (например,
запрос на завершение). Команда <code>kill</code> на самом деле
отправляет сигналы. Самые известные: <code>SIGTERM</code> (вежливо
попросить завершиться) и <code>SIGKILL</code> (принудительно
остановить).</li>
<li><strong>Аналогия</strong>: Как свисток судьи на футбольном поле —
игроки (процессы) должны на него отреагировать.</li>
</ul></li>
<li><strong>Job Control (Управление задачами)</strong>:
<ul>
<li><strong>Определение</strong>: Возможность shell управлять
несколькими процессами (задачами) из одной командной строки . Процесс
можно запустить в фоне (<code>&amp;</code>), приостановить
(<code>Ctrl+Z</code>), возобновить в фоне (<code>bg</code>) или вернуть
в активный режим (<code>fg</code>).</li>
<li><strong>Для нашей работы</strong>: Полезно, когда нужно запустить
длительную конвертацию и продолжить работу в терминале.</li>
</ul></li>
<li><strong>Command Substitution (Подстановка команд)</strong>:
<ul>
<li><strong>Определение</strong>: Возможность shell выполнить команду и
подставить её вывод в качестве аргументов для другой команды или
присвоить переменной . Синтаксис: <code>$(команда)</code> или обратные
кавычки <code>`команда`</code>.</li>
<li><strong>Пример</strong>: <code>files=$(find . -name "*.md")</code> —
в переменную <code>files</code> попадет список всех <code>.md</code>
файлов.</li>
</ul></li>
<li><strong>PATH (Переменная PATH)</strong>:
<ul>
<li><strong>Определение</strong>: Список директорий, в которых система
ищет исполняемые программы, когда вы вводите команду без указания
полного пути . Это ключевая переменная окружения.</li>
<li><strong>Для нашей работы</strong>: Мы добавляем <code>~/bin</code> в
PATH, чтобы наши команды (<code>генератор</code>, <code>мддок</code>)
были доступны из любой точки.</li>
</ul></li>
<li><strong>File Permissions (Права доступа к файлам)</strong>:
<ul>
<li><strong>Определение</strong>: Атрибуты файловой системы,
определяющие, какие пользователи и группы могут читать (<code>r</code>),
записывать (<code>w</code>) или исполнять (<code>x</code>) файл . Это
основа безопасности в Linux.</li>
<li><strong>Для нашей работы</strong>: Именно здесь возникает ошибка
<code>Permission denied</code>. Команда <code>chmod +x</code> изменяет
эти права, добавляя флаг “исполняемый”.</li>
</ul></li>
<li><strong>Shell (Оболочка)</strong>:
<ul>
<li><strong>Определение</strong>: Программа, предоставляющая доступ к
операционной системе через командную строку . Она интерпретирует
введенные команды и запускает соответствующие программы. Наша
стандартная оболочка — <code>bash</code> (Bourne-Again SHell).</li>
</ul></li>
<li><strong>Absolute Path (Абсолютный путь)</strong>:
<ul>
<li><strong>Определение</strong>: Полный путь к файлу или директории,
начинающийся от корня файловой системы (<code>/</code>) . Он однозначно
определяет местоположение файла независимо от текущей директории.</li>
<li><strong>Пример</strong>:
<code>/storage/emulated/0/Documents/05_Элект_книги/02_md_fb2_мдфб2/Идеология.md</code></li>
</ul></li>
<li><strong>Relative Path (Относительный путь)</strong>:
<ul>
<li><strong>Определение</strong>: Путь к файлу относительно текущей
рабочей директории . Использует обозначения <code>.</code> (текущая
директория) и <code>..</code> (родительская директория).</li>
<li><strong>Пример</strong>:
<code>../02_md_fb2_мдфб2/Идеология.md</code></li>
</ul></li>
<li><strong>Executable (Исполняемый файл)</strong>:
<ul>
<li><strong>Определение</strong>: Файл, который настроен для выполнения
как программа . В Unix-системах для этого у файла должны быть
установлены соответствующие права доступа (<code>chmod +x</code>).</li>
</ul></li>
<li><strong>Process (Процесс)</strong>:
<ul>
<li><strong>Определение</strong>: Запущенная программа, находящаяся в
памяти и использующая ресурсы системы . Каждый процесс имеет свой
уникальный идентификатор (PID).</li>
</ul></li>
<li><strong>Kernel (Ядро)</strong>:
<ul>
<li><strong>Определение</strong>: Центральная часть операционной
системы, которая всегда остается в памяти . Ядро управляет
оборудованием, создает процессы и обрабатывает все взаимодействия между
программами и аппаратурой.</li>
</ul></li>
<li><strong>GRUB (Grand Unified Boot Loader)</strong>:
<ul>
<li><strong>Определение</strong>: Загрузчик операционной системы на
современных Linux-системах . Отвечает за загрузку ядра при включении
компьютера.</li>
</ul></li>
</ul>
<h3 id="документооборот-и-конвертация-pandoc-2"><strong>2.
Документооборот и конвертация (Pandoc)</strong></h3>
<ul>
<li><strong>Filter (Фильтр)</strong>:
<ul>
<li><strong>Определение</strong>: Внешняя программа, которая может
модифицировать внутреннее представление документа (AST) в процессе
конвертации между чтением и записью. Это мощный инструмент для создания
собственных преобразований, которые невозможно сделать стандартными
средствами Pandoc.</li>
<li><strong>Для нашей работы</strong>: Например, можно написать фильтр
на Python, который будет находить в тексте все сноски и автоматически
форматировать их особым образом.</li>
</ul></li>
<li><strong>Template (Шаблон)</strong>:
<ul>
<li><strong>Определение</strong>: Файл, определяющий структуру выходного
документа. Pandoc использует встроенные шаблоны, но позволяет
переопределить их своими. Именно в шаблонах прописывается, куда вставить
метаданные (заголовок, автора), как оформить колонтитулы и т.д. В
контексте документооборота шаблон — это мастер-копия ключевого документа
.</li>
<li><strong>Для нашей работы</strong>: <code>--reference-doc</code> —
это частный случай шаблона для формата docx.</li>
</ul></li>
<li><strong>Blocks (Блоки)</strong>:
<ul>
<li><strong>Определение</strong>: Элементы для построения контента
документа . В редакторах документов это перетаскиваемые элементы:
текстовые блоки, таблицы, изображения, видео, оглавление и т.д. В Pandoc
блоками считаются структурные единицы документа (абзацы, заголовки,
списки, таблицы).</li>
<li><strong>Для нашей работы</strong>: Понимание блоков помогает
структурировать Markdown-документы.</li>
</ul></li>
<li><strong>Fields (Поля)</strong>:
<ul>
<li><strong>Определение</strong>: Элементы для сбора информации от
получателя . В редакторах документов это поля для подписи, даты,
заполняемые формы. В контексте Pandoc это соответствует метаданным и
переменным.</li>
</ul></li>
<li><strong>Variables (Переменные)</strong>:
<ul>
<li><strong>Определение</strong>: Текстовые заполнители для
автоматической подстановки динамической информации в документ .
Например, <code>[Client.FirstName]</code> или
<code>{{title}}</code>.</li>
<li><strong>Для нашей работы</strong>: В Pandoc это метаданные из
YAML-блока, которые подставляются в шаблон.</li>
</ul></li>
<li><strong>Content Library Items (Элементы библиотеки
контента)</strong>:
<ul>
<li><strong>Определение</strong>: Модульные фрагменты сохраненного
контента, которые можно вставлять в документы по мере необходимости . В
наших терминах — это шаблоны повторяющихся разделов.</li>
</ul></li>
<li><strong>Div / Span</strong>:
<ul>
<li><strong>Определение</strong>: Элементы-контейнеры в Pandoc (и HTML).
<code>Div</code> используется для блоков (например, целый абзац или
несколько абзацев), а <code>Span</code> — для фрагментов текста внутри
строки. Они позволяют применять атрибуты (классы, идентификаторы) к
целым разделам документа.</li>
</ul></li>
</ul>
<h3 id="структурное-программирование-и-архитектура-1"><strong>3.
Структурное программирование и архитектура</strong></h3>
<ul>
<li><strong>Structured Programming (Структурное
программирование)</strong>:
<ul>
<li><strong>Определение</strong>: Парадигма программирования, в основе
которой лежит представление программы в виде иерархической структуры
блоков, построенной из трёх базовых конструкций :
<ul>
<li><strong>последовательность</strong> — выполнение операций в том
порядке, в котором они записаны;</li>
<li><strong>ветвление</strong> — выбор одного из путей в зависимости от
условия (<code>if-then-else</code>);</li>
<li><strong>цикл</strong> — повторение операций пока выполняется
условие.</li>
</ul></li>
<li><strong>Ключевой принцип</strong>: Отказ от использования оператора
безусловного перехода (<code>goto</code>), который делал код запутанным
(“спагетти-код”) . Каждый модуль должен иметь один вход и один
выход.</li>
<li><strong>Для нашей работы</strong>: Это философская база, на которой
строятся наши скрипты. Мы пишем код, используя именно эти три
конструкции, что делает его читаемым и предсказуемым.</li>
</ul></li>
<li><strong>Modular Programming (Модульное программирование)</strong>:
<ul>
<li><strong>Определение</strong>: Подход, при котором программа
разбивается на независимые модули, каждый из которых отвечает за свою
функцию . Идеальный модуль можно изменить, не затрагивая другие части
программы.</li>
<li><strong>Для нашей работы</strong>: Мы реализовали это, разделив
функции: <code>генератор</code> создает команды, команды выполняют
конвертацию, отдельные скрипты для логирования.</li>
</ul></li>
<li><strong>Top-Down Design (Нисходящее проектирование)</strong>:
<ul>
<li><strong>Определение</strong>: Метод разработки, при котором сначала
определяется общая структура программы (верхний уровень), а затем
последовательно детализируются отдельные компоненты . Противоположность
— восходящее проектирование (снизу вверх).</li>
</ul></li>
<li><strong>Single Entry, Single Exit (Один вход, один выход)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, согласно которому каждый
модуль или функция должны иметь только одну точку входа и одну точку
выхода . Это упрощает понимание кода и отладку.</li>
</ul></li>
<li><strong>Control Structures (Управляющие конструкции)</strong>:
<ul>
<li><strong>Определение</strong>: Элементы языка, определяющие порядок
выполнения операций : последовательность, ветвление (<code>if</code>),
циклы (<code>for</code>, <code>while</code>), переключатель
(<code>case</code>).</li>
</ul></li>
<li><strong>Black Box Principle (Принцип черного ящика)</strong>:
<ul>
<li><strong>Определение</strong>: Часть алгоритма или программы,
реализующая некоторую функцию, с одним входом и одним выходом .
Внутреннее устройство скрыто, важно только то, что модуль делает, а не
как он это делает.</li>
</ul></li>
<li><strong>Böhm-Jacopini Theorem (Теорема Бёма-Якопини)</strong>:
<ul>
<li><strong>Определение</strong>: Фундаментальная теорема, доказывающая,
что любая программа может быть написана с использованием только трёх
базовых структур: последовательности, ветвления и цикла . Это
математическое обоснование структурного программирования.</li>
</ul></li>
<li><strong>Nassi-Shneiderman Diagrams (Схемы
Насси-Шнейдермана)</strong>:
<ul>
<li><strong>Определение</strong>: Графический способ представления
структурированных программ с помощью вложенных прямоугольников . Каждый
блок имеет форму прямоугольника и может быть вписан в любой внутренний
прямоугольник другого блока. Позволяют уменьшить громоздкость схем за
счёт отсутствия линий перехода.</li>
</ul></li>
<li><strong>DRY (Don’t Repeat Yourself)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, призывающий избегать
дублирования кода. Любая часть знания или логики должна иметь
единственное, непротиворечивое представление в системе.</li>
<li><strong>Для нашей работы</strong>: Мы реализовали это, создав скрипт
<code>генератор</code>, который создает все остальные команды по
шаблону.</li>
</ul></li>
<li><strong>KISS (Keep It Simple, Stupid!)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип проектирования, утверждающий,
что простота системы — ключ к ее успешной работе. Сложные решения всегда
хуже простых и понятных, так как их сложнее отлаживать и
поддерживать.</li>
</ul></li>
<li><strong>Separation of Concerns (Разделение
ответственности)</strong>:
<ul>
<li><strong>Определение</strong>: Принцип, при котором программа
разбивается на отдельные части, решающие свои узкие задачи, с
минимальным пересечением функциональности.</li>
</ul></li>
<li><strong>Refactoring (Рефакторинг)</strong>:
<ul>
<li><strong>Определение</strong>: Процесс изменения внутренней структуры
программы без изменения её внешнего поведения для улучшения понимания
кода и упрощения дальнейшего сопровождения.</li>
</ul></li>
</ul>
<h3 id="дополнительные-полезные-термины"><strong>4. Дополнительные
полезные термины</strong></h3>
<ul>
<li><strong>Boot Process (Процесс загрузки)</strong>:
<ul>
<li><strong>Определение</strong>: Последовательность шагов, которые
компьютер выполняет при включении для распознавания оборудования и
инициализации всех служб .</li>
</ul></li>
<li><strong>Master Boot Record (MBR, Главная загрузочная
запись)</strong>:
<ul>
<li><strong>Определение</strong>: Информация, хранящаяся в первом
секторе загрузочного диска, содержащая таблицу разделов и первый этап
загрузчика .</li>
</ul></li>
<li><strong>Package Manager (Менеджер пакетов)</strong>:
<ul>
<li><strong>Определение</strong>: Набор программных инструментов для
автоматизации установки, обновления, настройки и удаления программ . В
Termux это <code>pkg</code> (обертка над <code>apt</code>).</li>
</ul></li>
<li><strong>Loopback Interface (Интерфейс обратной связи)</strong>:
<ul>
<li><strong>Определение</strong>: Виртуальный сетевой интерфейс, который
отправляет пакеты обратно на ту же машину . Используется для
тестирования и внутренней коммуникации.</li>
</ul></li>
<li><strong>DHCP (Dynamic Host Configuration Protocol)</strong>:
<ul>
<li><strong>Определение</strong>: Протокол, позволяющий компьютерам
автоматически получать IP-адреса и другие сетевые настройки от
специального сервера .</li>
</ul></li>
</ul>
<hr />
<p>Этот расширенный список терминов охватывает большинство понятий,
которые могут встретиться в нашей работе. Если потребуются
дополнительные термины из других областей (например, по работе с Git,
базами данных или веб-технологиями), я готов продолжить.</p>
</body>
</html>
